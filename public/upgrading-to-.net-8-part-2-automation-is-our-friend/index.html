<!doctype html><html lang=en-gb><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><title>Upgrading to .NET 8: Part 2 - Automation is our Friend | The blog of a software developer and tester.</title>
<meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta property="author" content="Martin Costello"><meta name=copyright content="&copy; Martin Costello 2014-2025"><meta name=description content="Making it easier to test .NET previews using GitHub Actions for on-going automation."><meta name=language content="en"><meta name=theme-color content="#ffffff"><meta name=keywords content="dotnet,preview,upgrade,automation,github,actions"><meta name=robots content="INDEX"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="article:author" content="10100867762061905"><meta property="article:published_time" content="2023-07-11T00:00:00Z"><meta property="article:modified_time" content="2023-07-11T00:00:00Z"><meta property="article:tag" content="dotnet,preview,upgrade,automation,github,actions"><meta property="fb:profile_id" content="10100867762061905"><meta name=application-name content="Martin Costello's Blog"><meta name=msapplication-config content="browserconfig.xml"><meta name=msapplication-navbutton-color content="#0095DA"><meta name=msapplication-starturl content="/"><meta property="og:description" content="Making it easier to test .NET previews using GitHub Actions for on-going automation."><meta property="og:image" content="https://cdn.martincostello.com/blog_dotnet-8-upgrade-report.png"><meta property="og:locale" content="en_GB"><meta property="og:site_name" content="Martin Costello's Blog"><meta property="og:title" content="Upgrading to .NET 8: Part 2 - Automation is our Friend"><meta property="og:type" content="article"><meta property="og:updated_time" content="2023-07-11T00:00:00Z"><meta property="og:url" content="https://blog.martincostello.com/upgrading-to-.net-8-part-2-automation-is-our-friend/"><meta name=twitter:card content="summary"><meta name=twitter:creator content="@martin_costello"><meta name=twitter:description content="Making it easier to test .NET previews using GitHub Actions for on-going automation."><meta name=twitter:domain content="blog.martincostello.com"><meta name=twitter:image content="https://cdn.martincostello.com/blog_dotnet-8-upgrade-report.png"><meta name=twitter:image:alt content="Martin Costello"><meta name=twitter:site content="@martin_costello"><meta name=twitter:title content="Upgrading to .NET 8: Part 2 - Automation is our Friend"><meta name=twitter:url content="https://blog.martincostello.com/upgrading-to-.net-8-part-2-automation-is-our-friend/"><meta name=twitter:label1 content="Written by"><meta name=twitter:data1 content="Martin Costello"><meta name=google-site-verification content="ji6SNsPQEbNQmF252sQgQFswh-b6cDnNOa3AHvgo4J0"><meta name=msvalidate.01 content="D6C2E7551C902F1A396D8564C6452930"><link rel=canonical href=https://blog.martincostello.com/upgrading-to-.net-8-part-2-automation-is-our-friend/><link rel=manifest href=/manifest.webmanifest><link href=https://cdn.martincostello.com/favicon.ico rel="shortcut icon" type=image/x-icon><link href=/sitemap.xml rel=sitemap type=application/xml><link href=/feed.xml rel=alternate type=application/rss+xml title=Atom></head><body><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><div class=container><a href=/ class=navbar-brand><span class="fa-solid fa-laptop-code" aria-hidden=true></span>
blog.martincostello.com
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#site-navbar aria-controls=site-navbar aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=site-navbar><ul class="navbar-nav me-auto"><li class=nav-item><a class=nav-link href=/archive/ title="View the post archive">Archive
<span class="fa-solid fa-box-archive" aria-hidden=true></span></a></li></ul><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/about-me/ title="About Martin">About Me
<span class="fa-solid fa-circle-info" aria-hidden=true></span></a></li></ul></div></div></nav><main class="container body-content"><div class="p-4 mb-3 bg-light rounded-3"><div class="container-fluid py-3"><h1 class=display-5>Upgrading to .NET 8: Part 2 - Automation is our Friend</h1><p class="col-md-8 fs-4 lead">Making it easier to test .NET previews using GitHub Actions for on-going automation.</p></div></div><p><div class="row d-none d-md-block"><div class=col-6>11 July 2023 by <a href=/about-me/ rel=noopener title="About Martin Costello">Martin Costello</a> |
<a href=/feed.xml rel=noopener title="View the RSS syndication feed"><span class="fa-solid fa-rss" aria-hidden=true></span></a></div></div><div class="row d-md-none"><div class=col-12>11 July 2023 by <a href=/about-me/ rel=noopener title="About Martin Costello">Martin Costello</a></div><div class=col-12><a href=/feed.xml rel=noopener title="View the RSS syndication feed"><span class="fa-solid fa-rss" aria-hidden=true></span></a></p></div></div></p><p><div class=row><div class=col-lg-6><a href="https://bsky.app/intent/compose?text=Upgrading+to+.NET+8%3A+Part+2+-+Automation+is+our+Friend+by+%40martincostello.com+-+https%3A%2F%2Fblog.martincostello.com%2Fupgrading-to-.net-8-part-2-automation-is-our-friend%2F" target=_blank rel=noopener class="btn btn-info btn-sm" title="Share on Bluesky">Share on Bluesky
<span class="fa-brands fa-bluesky" aria-hidden=true></span></a></div></div></p><p>In <a href=https://blog.martincostello.com/upgrading-to-dotnet-8-part-1-why-upgrade title="Why Upgrade?">part 1 of this series</a> I recommended that you prepare to upgrade to .NET 8 and suggested
that you start off by testing the preview releases. Testing the preview releases is a great
way to get a head start on the upgrade process and to identify any issues sooner rather than
later, but it does require an investment of your time from preview to preview each month.</p><p>Even if you don&rsquo;t want to test new functionality, you still need to download the new .NET SDK,
update all the .NET SDK and NuGet package versions in your projects, and then test that everything
still works (that&rsquo;s already automated at least, right?). This can be a time-consuming process over
the course of a new .NET release, and it starts to become harder to scale if you want to test lots
of different codebases with the latest preview of the next .NET release.</p><p>What if we could automate some of this process so that we only need to focus on the parts
where we as humans really add value compared to the mechanical parts of an upgrade?</p><p>In part 2 of this series I&rsquo;m going to explain how I&rsquo;ve gone about automating the boring
parts of the process of testing the latest .NET preview releases using <a href=https://github.com/features/actions title="GitHub Actions">GitHub Actions</a>.</p><p>READMORE</p><h2 id=getting-started>Getting started</h2><p>The automation is intended to help with moving from preview to preview each month, but the first
preview you wish to test compared to the stable release of .NET 6 (or 7) you currently use will
need to be done manually.</p><p>This process can be relatively painless in most cases, requiring you to:</p><ol><li>Update your .NET SDK version in <code>global.json</code> to the latest preview release (e.g. <code>8.0.100-preview.5.23303.2</code>).</li><li>Update your Target Framework(s) to the latest version (e.g. <code>net6.0</code> to <code>net8.0</code>).</li><li>Update your NuGet package reference(s) to the latest preview versions (e.g. <code>8.0.0-preview.5.23280.8</code>).</li><li>Fixing (or suppressing - no judgement) any new .NET analyser errors flagged by the .NET SDK.</li><li>Fixing any breaking changes.</li><li>Ensuring all your tests still pass.</li></ol><p>With these steps in place, you can then commit the changes to a new branch and push it to GitHub.
To make things easy to automate by convention, I do things like this:</p><ul><li>The branch is named <code>dotnet-vnext</code> - this means we can reuse the process with minimal changes for .NET 9 in 2024 (and beyond).</li><li>The pull request is left in a draft state - this means it can&rsquo;t be merged until we&rsquo;re ready to do so (such as when the <code>8.0.100</code> is released).</li><li>Don&rsquo;t use a fork - it&rsquo;s much easier to manage merge conflicts over the branch&rsquo;s lifetime if you use a branch in the same repository.</li><li>Add <code>dotnet-vnext</code> as a triggering branch (e.g. for pull requests) for any GitHub Actions workflows that already run for <code>main</code>.</li></ul><p>With the one-off preparation to create the branch done, we&rsquo;re now ready to layer on the automation
and <a href=https://xkcd.com/1205/ title="Is It Worth the Time? on XKCD">save ourselves time in the long run</a>.</p><h2 id=updating-the-net-sdk-and-nuget-package-versions>Updating the .NET SDK and NuGet package versions</h2><p>In May I did a talk at <a href=https://dddsouthwest.com/ title="DDD South West">DDD South West</a> about how you can use GitHub Actions to automate the
process of updating your .NET projects to the latest patch version every month using my
<a href=https://github.com/marketplace/actions/update-net-sdk title="martincostello/update-dotnet-sdk on the GitHub Actions Marketplace">update-dotnet-sdk</a> GitHub Action and a GitHub Actions reusable workflow.</p><p>There&rsquo;s much more detail about how that works <a href=https://github.com/martincostello/dotnet-patch-automation-sample#readme title=".NET Patch Automation Sample">in the sample repository</a>,
but in a nutshell it uses the <a href=https://github.com/dotnet/core/tree/main/release-notes title=".NET release notes JSON on GitHub">.NET release notes JSON</a> in GitHub to determine
if there&rsquo;s a new .NET release available for a channel (.NET 6, .NET 7 etc.) and then raises a pull
request to update the <code>global.json</code> file in the repository to use the latest SDK version. It can also
optionally update your .NET NuGet packages to the latest patch version in the same pull request too.
For one of my repositories that uses SignalR <a href=https://github.com/martincostello/costellobot/blob/8a4352c5938f1c373ea8f64194bc352b5c243ed4/.github/workflows/update-dotnet-sdk.yml#L21-L82 title="Updating npm packages">I also extended it include the SignalR npm package</a>.</p><p>It occured to me that I could use the same process to update the version of the .NET SDK for the
current .NET preview release on a branch in the same way. By manually running the workflow to update
the .NET SDK on my <code>dotnet-vnext</code> branch instead of <code>main</code> I could then have the workflow raise a pull
request to automatically update the .NET SDK version to the latest preview release each month.</p><p>To prevent any issues from breaking the long-lived draft pull request for the .NET 8 upgrade itself,
I set up a branch protection rule for the <code>dotnet-vnext</code> branch with the following settings:</p><ul><li>Require a pull request before merging - this helps keep the branch stable from automation breakages</li><li>Require status checks to pass before merging (the same ones I use for <code>main</code>) - this ensures the CI passes before an update is merged</li><li>Allow force pushes (more on this later)</li><li>Allow bypassing the above settings - this allows a human to bypass the settings that are there to keep the automation in check</li></ul><p>Optionally (but recommended), you can then add further automation to handle reviewing and merging
these pull requests to the <code>dotnet-vnext</code> branch automatically if the CI passes. For my own repositories
I handle this using my own imaginatively named GitHub automation bot: <a href=https://github.com/martincostello/costellobot title="costellobot on GitHub">costellobot</a> (hey,
<a href=https://xkcd.com/910/ title="Permanence on XKCD">naming is hard</a>). There&rsquo;s another solution demonstrated in the <a href=https://github.com/martincostello/dotnet-patch-automation-sample#approving-and-merging-pull-requests title="Approving and Merging Pull Requests">sample repository</a>.</p><p>With this all set up, I can now manually run the workflow to update the .NET SDK version on the <code>dotnet-vnext</code>
branch when there&rsquo;s a preview version available. This is typically on <em><a href=https://en.wikipedia.org/wiki/Patch_Tuesday title="Patch Tuesday on Wikipedia">Patch Tuesday</a></em>
each month, but not always.</p><p>If the upgrade from one preview to the next goes without a hitch, then it automatically merges and there&rsquo;s
nothing that needs doing manually. I&rsquo;m then free to play with any new features in the latest preview release
separately.</p><p>If the CI fails, then I can investigate and fix/report the issue(s) before merging the pull request. It also
gives you a Git commit that&rsquo;s easy to share in a GitHub issue (assuming that your repository is public) to
make it easier for the .NET teams to triage and fix any issues you may find.</p><p>This approach makes it easy to focus your time on the parts that are important, rather than having to review <em>everything</em>. üòÆ‚Äçüí®</p><h2 id=rebasing-the-branches>Rebasing the branches</h2><p>A downside of a long-lived branch is that development work in the default branch of your repository likely
doesn&rsquo;t stop and things continue to move along.</p><p>This means that the <code>dotnet-vnext</code> branch can quickly start to accumulate merge conflicts as code is changed
in the default branch. This is particularly true for versions of NuGet packages and the .NET SDK, especially
if you use <a href=https://docs.github.com/code-security/dependabot/dependabot-version-updates/about-dependabot-version-updates title=Dependabot>Dependabot</a>.</p><p>While we can easily resolve these conflicts manually, it&rsquo;s quite tedious to do so, and it often just requires
you to manually pick the highest version of the dependency in question when there&rsquo;s a conflict on a line for
a <code>&lt;PackageReference></code>.</p><p>This sounds like yet another thing we can automate the process for, right?</p><p>For this I created a <a href=https://github.com/martincostello/github-automation/blob/main/.github/workflows/rebase.yml title="The rebase workflow on GitHub">GitHub Actions workflow</a> that runs on the <code>dotnet-vnext</code> branch and uses
the GitHub API and a custom command-line tool I wrote called <em><a href=https://github.com/martincostello/github-automation/blob/main/src/Rebaser/Program.cs title="Rebaser on GitHub">Rebaser</a></em> (<a href="https://www.youtube.com/watch?v=PVyS9JwtFoQ" title="Rebaser by The Pixies on YouTube">namesake</a>) to automatically
rebase the branch and force-push the changes back to the branch (this is why we allowed force pushes on the
branch when we set up the branch protection rules).</p><p>This workflow uses the GitHub API to <a href="https://docs.github.com/rest/commits/commits?apiVersion=2022-11-28#list-pull-requests-associated-with-a-commit" title="List pull requests associated with a commit">find the pull request associated with the <code>dotnet-vnext</code> branch</a>
and checks the value of the <code>mergeable_state</code> property of the response. If the value is <code>dirty</code>, then the branch
has conflicts and needs to be rebased. We ignore other merge states as they don&rsquo;t need us to do anything most of the time.</p><p>If the merge state of the branch is found to be <em>&ldquo;dirty&rdquo;</em>, then Rebaser is run against the repository to rebase
the branch. If any simple conflicts caused by version numbers are found, then it will attempt to resolve them
itself by always chosing the higher version number for the dependency in question. If Rebaser cannot automatically
resolve the conflict, then the rebase is aborted and the workflow emits a warning for a human to resolve the
conflict manually.</p><p>In the case where a manual conflict needs to be resolved, Rebaser can be run locally with the <code>--interactive</code> flag
specified. This opens Visual Studio Code for each file with a confict in turn and lets the user then leverage
the built-in merge conflict resolution UI to resolve the conflict(s) and then save the file to continue the rebase.
This is really useful in the case where there&rsquo;s lots of easily resolvable conflicts, but a there&rsquo;s just a single
change that needs some manual intervention. In these cases, Rebaser can do the heavy lifting for most of the changes
(the boring ones), and us humans can just focus on the few that need manual attention.</p><h2 id=stiching-things-together>Stiching things together</h2><p>At this point we have a workflow that does our version updates for us and another that rebases the branch when it
needs it, but both of these workflows need to be run manually. That&rsquo;s not very automated, is it?</p><img class="img-fluid mx-auto d-block" src=https://cdn.martincostello.com/blog_an-automated-solution.gif alt="A drinking bird pressing a button on a keyboard" title="A drinking bird pressing a button on a keyboard"><p>What if we could automate the automation (whoa, meta) to run the workflows for us when we need them to? What if we
could run the workflows for <em>all</em> of the repositories we&rsquo;re testing .NET previews with? That sounds like something
that would really save us some time each month.</p><h3 id=checking-for-new-releases>Checking for new releases</h3><ul><li><a href=https://github.com/martincostello/github-automation/blob/main/.github/workflows/dotnet-release.yml title="dotnet-release workflow on GitHub">A workflow</a> checks the <a href=https://github.com/dotnet/core/tree/main/release-notes title=".NET release notes JSON on GitHub">dotnet/core</a> repository for changes to the <code>release-notes/**/releases.json</code> file(s).</li><li>When changes are found, which <em>usually</em> implies a new release is available, the workflow <a href="https://docs.github.com/rest/repos/repos?apiVersion=2022-11-28#create-a-repository-dispatch-event" title="Create a repository dispatch event">raises a repository dispatch event</a> named <code>dotnet_release</code>.</li><li>This event triggers the <a href=https://github.com/martincostello/github-automation/blob/main/.github/workflows/update-dotnet-sdks.yml title="update-dotnet-sdks workflow on GitHub"><code>update-dotnet-sdks</code></a> workflow which runs the <code>update-dotnet-sdk</code> workflow in each repository that has opted-in to the automation for the <code>main</code> branch. This isn&rsquo;t run for <code>dotnet-vnext</code> at the moment as when the release notes change there&rsquo;s likely a new version of .NET 6, 7 and 8 at the same time. Running just for <code>main</code> means we can get the .NET 6/7 updates applied to it first, and then the .NET 8 updates later as it would just create a merge conflict anyway.</li></ul><p><s>In the future I might extend this to be smarter and determine whether a preview (or not) has been released, and then run the workflow for either <code>main</code> or <code>dotnet-vnext</code> as appropriate.</s></p><p>I updated the workflow above to handle this scenario. It now checks the <code>release-notes/**/releases.json</code> file(s) for the latest version(s) of .NET that have been released. If any version is a preview, then it will run the workflow for <code>dotnet-vnext</code>; for any others it will run the workflow for <code>main</code>. The commit that made those changes can be <a href=https://github.com/martincostello/github-automation/commit/5cb88f4805e6181ec4a6ace53a6164ca524e21af title="Run SDK update for previews - martincostello/github-automation@5cb88f4">found here</a>.</p><h3 id=checking-for-conflicts>Checking for conflicts</h3><ul><li><a href=https://github.com/martincostello/costellobot title="costellobot on GitHub">Costellobot</a> receives <a href=https://docs.github.com/webhooks-and-events/webhooks/webhook-events-and-payloads#push title="push webhook event on GitHub">webhook payloads for pushes</a> to the repositories it is installed in.</li><li>If a change has been found to have been made in the default branch <a href=https://github.com/martincostello/costellobot/blob/8a4352c5938f1c373ea8f64194bc352b5c243ed4/src/Costellobot/Handlers/PushHandler.cs#L60-L82 title="DependencyFileChanged() method">to a file that could cause a conflict</a> in the <code>dotnet-vnext</code> branch, then the bot will <a href="https://docs.github.com/rest/repos/repos?apiVersion=2022-11-28#create-a-repository-dispatch-event" title="Create a repository dispatch event">raise a repository dispatch event</a> named <code>dotnet_dependencies_updated</code>.</li><li>This event triggers the <a href=https://github.com/martincostello/github-automation/blob/main/.github/workflows/rebase.yml title="The rebase workflow on GitHub"><code>rebase</code></a> workflow for just that repository, which will then rebase the branch if needed as described above.</li></ul><p>A sequence diagram of how all the workflows and events fit together is shown below.</p><a href=https://github.com/martincostello/github-automation/blob/main/docs/dotnet-vnext.md#sequence-diagram target=_blank><img class="img-fluid mx-auto d-block" src=https://cdn.martincostello.com/blog_dotnet-vnext-sequence.png alt="A sequence diagram showing the automated workflow" title="A sequence diagram showing the automated workflow"></a><p>More detailed information about how the workflows above operate can be found in <em><a href=https://github.com/martincostello/github-automation/blob/main/docs/dotnet-vnext.md title="Testing .NET vNext">Testing .NET vNext</a></em>.</p><h2 id=whats-the-status-of-the-upgrade>What&rsquo;s the status of the upgrade?</h2><p>With all this in place, it would be good to know the status of everything in one place. Information that would be good to show includes:</p><ul><li>What version of the .NET SDK is being used?</li><li>Is the <code>dotnet-vnext</code> branch using the latest preview version?</li><li>Is the pull request&rsquo;s CI passing?</li><li>Are there any merge conflicts?</li></ul><p>GitHub Actions once again comes to the rescue here, as we can use it to create a workflow that uses
the <a href=https://cli.github.com/ title="GitHub CLI">GitHub CLI</a> to easily query the state of the pull requests in our branches and then
generate a Markdown report using <em><a href=https://github.blog/2022-05-09-supercharging-github-actions-with-job-summaries/ title="Supercharging GitHub Actions with Job Summaries on the GitHub Blog">Step Summaries</a></em>. This shows us a table
of all of the repositories we&rsquo;re testing .NET 8 with and uses <a href=https://shields.io/badges title="shields.io badges">shields.io</a> to generate a
badge that we can use to tell at-a-glance if there&rsquo;s something not right with any repository.</p><p>With some inline PowerShell script and the GitHub CLI (<code>gh</code>), the <a href=https://github.com/martincostello/github-automation/blob/main/.github/workflows/dotnet-upgrade-report.yml title="dotnet-upgrade-report workflow on GitHub">dotnet-upgrade-report workflow</a>
generates a report that provides us with the information we need, using colour coding to draw attention to
any rows that might be of interest. An example of the report can be found <a href=https://github.com/martincostello/github-automation/actions/runs/5506134751 title="Example .NET vNext Upgrade Report">here</a>.</p><p>Here&rsquo;s a snippet from one as an example:</p><img class="img-fluid mx-auto d-block w-75" src=https://cdn.martincostello.com/blog_dotnet-8-upgrade-report.png alt="An example upgrade report showing the status of 9 repositories' upgrades" title="An example upgrade report showing the status of 9 repositories' upgrades"><p>As you can see above, at the time the report was generated all of the repositories&rsquo; CI were passing and
using the latest .NET 8 preview SDK, but the <a href=https://github.com/martincostello/adventofcode title="martincostello/adventofcode on GitHub">adventofcode repository</a> had a merge
conflict that needed resolving.</p><p>The report can be generated on-demand by running the workflow manually, but is is also scheduled to run
at 10:00 on working days.</p><p>This report allows us to easily track the status of our testing over the course of the preview releases
as well as providing us with an index that allows us to pivot to our pull requests.</p><h2 id=humans-are-still-needed>Humans are still needed</h2><p>With long-lived branches like <code>dotnet-vnext</code> being around potentally for months accumulating changes, it&rsquo;s
possible that over time the amount of change in the pull request will snowball and become a larger proposition
to review and merge when the time comes. Developers typically aren&rsquo;t fans of large pull requests with hundreds
of changed lines!</p><p>Yet not all of these changes need to wait until .NET 8 is released - some of these changes may be safe to merge
into your <code>main</code> branch now.</p><p>One example of this is the new <a href=https://learn.microsoft.com/en-gb/dotnet/fundamentals/code-analysis/quality-rules/ca1859 title="CA1859: Use concrete types when possible for improved performance">CA1859</a> code analysis rule. This rule suggests that concrete types are
used where possible to improve performance. For example, instead of using <code>IList&lt;T></code> as the type for a private
field in a class you should use <code>List&lt;T></code>. This is because the Just-In-Time compiler (JIT) might be able to
<em><a href=https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/#jit title="Performance Improvements in .NET 6">&ldquo;devirtualize&rdquo;</a></em> the calls to the methods on the concrete type, which can improve performance.</p><p>In the case of CA1859, resolving these analysis warnings doesn&rsquo;t rely on the use of the .NET 8 SDK nor any new
APIs. This means that you can safely apply these changes to your default branch now with .NET 6 or 7. The &ldquo;only&rdquo;
thing .NET 8 did was bring the <em>capability to detect</em> these issues to us. Not waiting for these changes to be made
until our .NET 8 upgrade is merged means that we can not only benefit from the performance improvements now, but
we also reduce the size of the Git diff in our pull request, making it easier to review and merge when the time comes.
The only downside is that someone could change the code back in the default branch and regress the behaviour,
but I think that&rsquo;s a small issue compared to the benefits of making such changes now.</p><h2 id=summary>Summary</h2><p>Using the workflows described above in my <a href=https://github.com/martincostello/github-automation title="GitHub Automation repository on GitHub">github-automation</a> repository, I&rsquo;ve been able to automate
a lot of the boring parts of upgrading from one .NET preview to the next. These workflows have allowed me to:</p><ul><li>Watch for new .NET versions using the JSON release notes</li><li>Use the <a href=https://github.com/marketplace/actions/update-net-sdk title="martincostello/update-dotnet-sdk on the GitHub Actions Marketplace">update-dotnet-sdk</a> GitHub action to update the .NET SDK and NuGet packages for the repositories we&rsquo;re testing</li><li>Keep changes that break the CI in a separate branch and pull request for manual inspection <s>if</s> when an issue is found</li><li>Automatically rebase the <code>dotnet-vnext</code> branch as and when needed (or make it easier to do so manually)</li></ul><p>With these parts automated, we can focus on the more interesting parts of the process that come up, like any issues we
might find, or trying out new functionality in the latest preview releases. Nice. üòé</p><p>I hope you find the automation I&rsquo;ve described above useful and an inspiration for automating .NET version upgrades
for your own application repositories.</p><p>In part 3 of this series, we&rsquo;ll look at some of the changes that have been introduced in the first five preview
releases of .NET 8 and some of the interesting issues testing them uncovered: <em><a href=https://blog.martincostello.com/upgrading-to-dotnet-8-part-3-previews-1-to-5 title="Previews 1-5">Part 3 - Previews 1-5</a></em>.</p><h2 id=upgrading-to-net-8-series-links>Upgrading to .NET 8 Series Links</h2><p>You can find links to the other posts in this series below.</p><ul><li><a href=https://blog.martincostello.com/upgrading-to-dotnet-8-part-1-why-upgrade title="Why Upgrade?">Part 1 - Why Upgrade?</a></li><li>Part 2 - Automation is our Friend (this post)</li><li><a href=https://blog.martincostello.com/upgrading-to-dotnet-8-part-3-previews-1-to-5 title="Previews 1-5">Part 3 - Previews 1-5</a></li><li><a href=https://blog.martincostello.com/upgrading-to-dotnet-8-part-4-preview-6 title="Preview 6">Part 4 - Preview 6</a></li><li><a href=https://blog.martincostello.com/upgrading-to-dotnet-8-part-5-preview-7-and-rc-1-2 title="Preview 7 and Release Candidates 1 and 2">Part 5 - Preview 7 and Release Candidates 1 and 2</a></li><li><a href=https://blog.martincostello.com/upgrading-to-dotnet-8-part-6-stable-release title="The Stable Release">Part 6 - The Stable Release</a></li></ul><hr><p><div class=row><div class=col-lg-6><a href="https://bsky.app/intent/compose?text=Upgrading+to+.NET+8%3A+Part+2+-+Automation+is+our+Friend+by+%40martincostello.com+-+https%3A%2F%2Fblog.martincostello.com%2Fupgrading-to-.net-8-part-2-automation-is-our-friend%2F" target=_blank rel=noopener class="btn btn-info btn-sm" title="Share on Bluesky">Share on Bluesky
<span class="fa-brands fa-bluesky" aria-hidden=true></span></a></div></div></p><hr><footer><p><div class=row><div class="d-none d-md-block col">&copy; Martin Costello 2014-2025 |
Built from <a href=https://github.com/martincostello/blog/commit/main rel=noopener title="View commit main on GitHub">main</a> on <a href=https://github.com/martincostello/blog/tree/main rel=noopener title="View branch main on GitHub">main</a></div><div class=d-md-none><div class=col>&copy; Martin Costello 2014-2025</div></div></div></p></footer></main><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.7/flatly/bootstrap.min.css integrity="sha512-O+EA0Agf5+pB8u7CtnIAYq/BKyFPMT8c0DFjmqLyfIJJ9Fm8GBohV/0H0TFaZ96+jieN8zUVY4IkSBso9z6hpg==" crossorigin=anonymous referrerpolicy=no-referrer async><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer async><link rel=stylesheet href=/styles/site.css><script src=https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.7/js/bootstrap.bundle.min.js integrity="sha512-Tc0i+vRogmX4NN7tuLbQfBxa8JkfUSAxSFVzmU31nVdHyiHElPPy2cWfFacmCJKw0VqovrzKhdd2TSTMdAxp2g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src="https://www.googletagmanager.com/gtag/js?id=G-XJFV74HRL6" async></script><script>window.hugoSiteParams={render_analytics:!0,analytics_id:"G-XJFV74HRL6"}</script><script src=/scripts/site.js defer></script></body></html>