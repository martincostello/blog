<!doctype html><html lang=en-gb><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><title>Prototyping Sign In with Apple for ASP.NET Core | The blog of a software developer and tester.</title>
<meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta property="author" content="Martin Costello"><meta name=copyright content="&copy; Martin Costello 2014-2025"><meta name=description content="Prototyping an integration with ASP.NET Core for Sign In with Apple"><meta name=language content="en"><meta name=theme-color content="#ffffff"><meta name=keywords content="aspnetcore,dotnet,apple,sign in with apple"><meta name=robots content="INDEX"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="article:author" content="10100867762061905"><meta property="article:published_time" content="2019-06-10T00:00:00Z"><meta property="article:modified_time" content="2019-06-10T00:00:00Z"><meta property="article:tag" content="aspnetcore,dotnet,apple,sign in with apple"><meta property="fb:profile_id" content="10100867762061905"><meta name=application-name content="Martin Costello's Blog"><meta name=msapplication-config content="browserconfig.xml"><meta name=msapplication-navbutton-color content="#0095DA"><meta name=msapplication-starturl content="/"><meta property="og:description" content="Prototyping an integration with ASP.NET Core for Sign In with Apple"><meta property="og:image" content="https://cdn.martincostello.com/martin_small-v3.png"><meta property="og:locale" content="en_GB"><meta property="og:site_name" content="Martin Costello's Blog"><meta property="og:title" content="Prototyping Sign In with Apple for ASP.NET Core"><meta property="og:type" content="article"><meta property="og:updated_time" content="2019-06-10T00:00:00Z"><meta property="og:url" content="https://blog.martincostello.com/prototyping-sign-in-with-apple-for-asp.net-core/"><meta name=twitter:card content="summary"><meta name=twitter:creator content="@martin_costello"><meta name=twitter:description content="Prototyping an integration with ASP.NET Core for Sign In with Apple"><meta name=twitter:domain content="blog.martincostello.com"><meta name=twitter:image content="https://cdn.martincostello.com/martin_small-v3.png"><meta name=twitter:image:alt content="Martin Costello"><meta name=twitter:site content="@martin_costello"><meta name=twitter:title content="Prototyping Sign In with Apple for ASP.NET Core"><meta name=twitter:url content="https://blog.martincostello.com/prototyping-sign-in-with-apple-for-asp.net-core/"><meta name=twitter:label1 content="Written by"><meta name=twitter:data1 content="Martin Costello"><meta name=google-site-verification content="ji6SNsPQEbNQmF252sQgQFswh-b6cDnNOa3AHvgo4J0"><meta name=msvalidate.01 content="D6C2E7551C902F1A396D8564C6452930"><link rel=canonical href=https://blog.martincostello.com/prototyping-sign-in-with-apple-for-asp.net-core/><link rel=manifest href=/manifest.webmanifest><link href=https://cdn.martincostello.com/favicon.ico rel="shortcut icon" type=image/x-icon><link href=/sitemap.xml rel=sitemap type=application/xml><link href=/feed.xml rel=alternate type=application/rss+xml title=Atom></head><body><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><div class=container><a href=/ class=navbar-brand><span class="fa-solid fa-laptop-code" aria-hidden=true></span>
blog.martincostello.com
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#site-navbar aria-controls=site-navbar aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=site-navbar><ul class="navbar-nav me-auto"><li class=nav-item><a class=nav-link href=/archive/ title="View the post archive">Archive
<span class="fa-solid fa-box-archive" aria-hidden=true></span></a></li></ul><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/about-me/ title="About Martin">About Me
<span class="fa-solid fa-circle-info" aria-hidden=true></span></a></li></ul></div></div></nav><main class="container body-content"><div class="p-4 mb-3 bg-light rounded-3"><div class="container-fluid py-3"><h1 class=display-5>Prototyping Sign In with Apple for ASP.NET Core</h1><p class="col-md-8 fs-4 lead">Prototyping an integration with ASP.NET Core for Sign In with Apple</p></div></div><p><div class="row d-none d-md-block"><div class=col-6>10 June 2019 by <a href=/about-me/ rel=noopener title="About Martin Costello">Martin Costello</a> |
<a href=/feed.xml rel=noopener title="View the RSS syndication feed"><span class="fa-solid fa-rss" aria-hidden=true></span></a></div></div><div class="row d-md-none"><div class=col-12>10 June 2019 by <a href=/about-me/ rel=noopener title="About Martin Costello">Martin Costello</a></div><div class=col-12><a href=/feed.xml rel=noopener title="View the RSS syndication feed"><span class="fa-solid fa-rss" aria-hidden=true></span></a></p></div></div></p><p><div class=row><div class=col-lg-6><a href="https://bsky.app/intent/compose?text=Prototyping+Sign+In+with+Apple+for+ASP.NET+Core+by+%40martincostello.com+-+https%3A%2F%2Fblog.martincostello.com%2Fprototyping-sign-in-with-apple-for-asp.net-core%2F" target=_blank rel=noopener class="btn btn-info btn-sm" title="Share on Bluesky">Share on Bluesky
<span class="fa-brands fa-bluesky" aria-hidden=true></span></a></div></div></p><p>Last week at Apple&rsquo;s <a href=https://developer.apple.com/wwdc19/ title=WWDC19>WWDC 2019</a> conference, Apple announced a forthcoming service for enabling users to log into apps and services using their Apple ID, <a href=https://developer.apple.com/sign-in-with-apple/ title="Sign In with Apple"><em>Sign In with Apple</em></a>.</p><p>The main points of note about the new service are:</p><ul><li>Users can sign in without having to give their email address to a third-party;</li><li>It will be required as an option in the future for apps that support third-party sign-in.</li></ul><p>Just <em>one day</em> after the announcement at WWDC19, <a href=https://github.com/leastprivilege title="@leastprivilege on GitHub.com">@leastprivilege</a> of Identity Server fame, opened a <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/issues/314 title="Support for Apple Sign-in on GitHub.com">GitHub issue</a> over at the <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers title="AspNet.Security.OAuth.Providers on GitHub.com"><em>AspNet.Security.OAuth.Providers</em></a> repository requesting a provider to support <em>Sign In with Apple</em>.</p><p>While the issue was opened slightly tongue-in-cheek, it&rsquo;s a valid start to the conversation about investigating support for this new technology (or not).</p><p>I&rsquo;ve recently become a maintainer of the <a href=https://github.com/aspnet-contrib title="aspnet-contrib org on GitHub.com">aspnet-contrib</a> organisation in GitHub.com, which provides a suite of community-written providers for various OAuth 2.0 and Open ID 2.0 third-party authentication providers. Over the last few years I&rsquo;ve made a number of contributions; for an <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/157 title="Add Amazon provider">Amazon Login provider</a>, and most recently starting the work to <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/280 title="Support ASP.NET Core 3.0">add support for ASP.NET Core 3.0</a>.</p><p>Given the community discussion and appetite, some previous experience implementing <a href=https://blog.martincostello.com/bringing-apple-pay-to-the-web title="Bringing Apple Pay to the web">Apple Pay JS for ASP.NET Core</a>, and some shiny new technology to play with, last I decided to try my hand at adding support for <em>Sign In with Apple</em> for ASP.NET Core myself via <em>AspNet.Security.OAuth.Providers</em>.</p><p>READMORE</p><p>Others have already blogged in great detail about the <em>what</em> of <em>Sign In with Apple</em>, including <a href=https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple title="What the Heck is Sign In with Apple?">Aaron Parecki</a> of okta and <a href=https://auth0.com/blog/what-is-sign-in-with-apple-a-new-identity-provider/ title="Sign In with Apple: Learn About the New Identity Provider">Bruno Krebs</a> of auth0, so I won&rsquo;t reiterate the information they&rsquo;ve covered there. Instead I&rsquo;ll focus on the ASP.NET Core integration specifics for how to get the service working with the REST API instead.</p><p>If you want to skip ahead, you can see the draft pull request for the <em>Sign In with Apple</em> provider <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/318 title="Sign in With Apple provider">here</a>, and a working demo you can try out for yourself here: <a href=https://signinwithapple.azurewebsites.net/ title="Sign In with Apple demo application">signinwithapple.azurewebsites.net</a></p><h2 id=integrating-with-_sign-in-with-apple_>Integrating with <em>Sign In with Apple</em></h2><h3 id=boostrapping>Boostrapping</h3><p>The very first step was very easy, as that just required creating the project template to start coding the implementation into. In fact, <em>AspNet.Security.OAuth.Providers</em> has a <a href=https://github.com/aspnet-contrib/generator-aspnet-oauth title="generator-aspnet-oauth on GitHub.com">Yeoman generator</a> which lets you bootstrap the scaffolding into the repo fairly quickly.</p><p>The latest version for ASP.NET Core 2.0 isn&rsquo;t available in <a href=https://www.npmjs.com/package/generator-aspnet-oauth title="generator-aspnet-oauth on the npm registry">npmjs.org</a> yet, but with a recent enough version of Yeoman you can run the generator directly from source as shown below.</p><pre tabindex=0><code>&gt; git clone https://github.com/aspnet-contrib/generator-aspnet-oauth.git
&gt; git clone https://github.com/martincostello/AspNet.Security.OAuth.Providers.git
&gt; cd AspNet.Security.OAuth.Providers\src
&gt; git checkout -b Sign-In-With-Apple
&gt; yo ..\..\generator-aspnet-oauth\generators\app\index.js

     _-----_     ╭──────────────────────────╮
    |       |    │   Welcome to the classy  │
    |--(o)--|    │  ASP.NET OAuth Provider  │
   `---------´   │        generator!        │
    ( _´U`_ )    ╰──────────────────────────╯
    /___A___\   /
     |  ~  |
   __&#39;.___.&#39;__
 ´   `  |° ´ Y `

? What is the name of the provider you want to create? Apple
? What is your name? Martin Costello
? What is the Authorization Endpoint for this service? https://appleid.apple.com/auth/authorize
? What is the Token Endpoint for this service? https://appleid.apple.com/auth/token
? What is the User Information Endpoint for this service? https://appleid.apple.com/auth/user
   create AspNet.Security.OAuth.Apple\AspNet.Security.OAuth.Apple.csproj
   create AspNet.Security.OAuth.Apple\AppleAuthenticationDefaults.cs
   create AspNet.Security.OAuth.Apple\AppleAuthenticationExtensions.cs
   create AspNet.Security.OAuth.Apple\AppleAuthenticationHandler.cs
   create AspNet.Security.OAuth.Apple\AppleAuthenticationOptions.cs
</code></pre><p>Here the URL of the User Information Endpoint was a guess, and I ended up deleting it for now as there isn&rsquo;t one documented.</p><p>With that done, I had a skeleton to start iterating on once I followed the <a href=https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple#how-sign-in-with-apple-works-hint-it-uses-oauth-and-oidc title="How Sign In with Apple Works (Hint: it uses OAuth and OIDC)">excellent guide</a> Aaron Parecki put together which explains how to set up the various apps, services, certificates and keys you need to create in the Apple Developer website to get started.</p><p>To implement things, I set up a free Azure App Service website to quickly get something publicly hosted I could publish to from Visual Studio for rapid prototyping (don&rsquo;t judge me, it&rsquo;s faster for this use case), as well as to leverage the free HTTPS support which is required. This gave me a domain (<code>signinwithapple.azurewebsites.net</code>) to configure for the certificates and callback URL.</p><p>The <em>TL;DR</em> of what you need is:</p><ul><li>An App ID (for your Services ID)</li><li>A Services ID (for your <em>Client Id</em>)</li><li>An <em>Apple Developer Domain Association</em> file (or two) to verify your sign-in and email domain(s)</li><li>A private key (to generate your <em>Client Secret</em>)</li><li>Appropriate DNS <code>MX</code> record(s) in your DNS zone (for email relay, even if you don&rsquo;t intend to use it)</li></ul><p>For the email relay I just verified my main .com domain as it already has MX records setup, plus I don&rsquo;t intend to actually leverage the email addresses from the signed-in users to send any emails.</p><p>With these all configured and downloaded, I had the values ready to try things out.</p><p>I deployed the <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/samples/Mvc.Client title="Mvc.Client sample app on GitHub.com">MVC sample app</a> from <em>AspNet.Security.OAuth.Providers</em> to the new Azure App Service slot to act as the testbed for the Apple provider.</p><h3 id=_wheres-the-client-secret_><em>&ldquo;Where&rsquo;s the client secret?&rdquo;</em></h3><p>Something different about <em>Sign In with Apple</em> compared to most OAuth 2.0 based authentication providers is that Apple don&rsquo;t actually provide you with a client secret. Instead they provide you with a PKCS #8 (<code>.p8</code>) private key which you then use to generate a JSON Web Token (JWT) to use as the client secret. Apple requires that these have a validity period of no longer than 6 months, so you can&rsquo;t just generate a value as a one-off and use it forever more.</p><p>To start with I used Aaron&rsquo;s <a href=https://github.com/aaronpk/sign-in-with-apple-example/blob/master/client-secret.rb title=client-secret.rb><code>client-secret.rb</code></a> Ruby script from Windows Subsystem for Linux (WSL) to generate a client secret from my <em>Team ID</em>, <em>Key ID</em>, <em>Services ID</em> (which acts as your OAuth <em>Client ID</em>) and the <code>.p8</code> private key file.</p><p>This then let me check that the <em>basic</em> integration flow worked and that I could get the Apple login ID back to the client application code.</p><p>With some logging, it also gave me some real values to use for further testing locally to iterate on getting the values from the <code>id_token</code> property in the <a href=https://developer.apple.com/documentation/signinwithapplerestapi/tokenresponse title="TokenResponse object">token response</a>.</p><h3 id=id-token-decoding>ID Token Decoding</h3><p>As <a href=https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens title="Generate and validate tokens">discussed</a> in the Apple Developer documentation, the <code>id_token</code> value is a signed JWT value.</p><p>These can be <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/b9a72d4928eff6bfe550e5f3abb3da3c81199090/src/AspNet.Security.OAuth.Apple/AppleAuthenticationHandler.cs#L110-L121 title>easily decoded</a> using the <a href=https://www.nuget.org/packages/System.IdentityModel.Tokens.Jwt/ title="System.IdentityModel.Tokens.Jwt on NuGet.org">System.IdentityModel.Tokens.Jwt</a> library:</p><pre tabindex=0><code>// dotnet add System.IdentityModel.Tokens.Jwt

// Get the ID token from the OAuth token response
OAuthTokenResponse tokens = ...;
string token = tokens.Response.Value&lt;string&gt;(&#34;id_token&#34;);

// Parse the JWT
var tokenHandler = new JwtSecurityTokenHandler();
var userToken = tokenHandler.ReadJwtToken(token);

// Get the subject to use for the Name Identifier claim
string subject = userToken.Subject;
</code></pre><p>Without a <em>User Information Endpoint</em> available, this is actually as much information as we can currently get about the user right now anyway!</p><h3 id=token-validation>Token Validation</h3><p>Also <a href=https://developer.apple.com/documentation/signinwithapplerestapi/fetch_apple_s_public_key_for_verifying_token_signature title="Fetch Apple's public key for verifying token signature">discussed in the documentation</a> is an endpoint for retrieving the Apple public key to validate the signature of the ID token.</p><p>Again, this is <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/b9a72d4928eff6bfe550e5f3abb3da3c81199090/src/AspNet.Security.OAuth.Apple/Internal/DefaultAppleIdTokenValidator.cs#L40-L55>relatively easy</a> to do using the System.IdentityModel.Tokens.Jwt package.</p><pre tabindex=0><code>// Get the ID token from the OAuth token response
OAuthTokenResponse tokens = ...;
string token = tokens.Response.Value&lt;string&gt;(&#34;id_token&#34;);

// Get the public keys from https://appleid.apple.com/auth/keys
string keysJson = await ...;

// Parse the keys
JsonWebKeySet keySet = JsonWebKeySet.Create(keysJson);

// Setup the validation parameters
var parameters = new TokenValidationParameters()
{
    ValidAudience = &#34;{YOUR CLIENT ID}&#34;,
    ValidIssuer = &#34;https://appleid.apple.com&#34;,
    IssuerSigningKeys = keySet.Keys,
};

// Validate the token - ValidateToken(...) throws an exception if it is invalid
var tokenHandler = new JwtSecurityTokenHandler();
tokenHandler.ValidateToken(context.IdToken, parameters, out var _);
</code></pre><p>In the prototype provider implementation the Apple public keys are cached on the assumption that they rotate infrequently to increase performance by removing the need to perform an additional HTTP call for each user log in.</p><p>This is something that I might make configurable before the final release, so it is up the integrator whether to always re-fetch the public keys, but in the prototype integrators can already provide their own <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/b9a72d4928eff6bfe550e5f3abb3da3c81199090/src/AspNet.Security.OAuth.Apple/AppleKeyStore.cs title="AppleKeyStore class on GitHub.com"><code>AppleKeyStore</code></a> to change to implementation of how the public key is retrieved and stored.</p><h3 id=generating-the-client-secret-in-the-app>Generating the Client Secret in the app</h3><p>With the basic end-to-end flow working using the Client Secret generated using the Ruby script completed, the next step in the implementation was to make it easier for the integrator by building in the ability to <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/b9a72d4928eff6bfe550e5f3abb3da3c81199090/src/AspNet.Security.OAuth.Apple/AppleAuthenticationHandler.cs#L98-L108>dynamically generate it</a> from they various IDs and the private key.</p><p>This was the trickiest bit to get working (more on that a bit later), but again is mostly solved by the System.IdentityModel.Tokens.Jwt package.</p><pre tabindex=0><code>// Generate a token valid for the maximum 6 months
var expiresAt = DateTime.UtcNow.Add(TimeSpan.FromSeconds(15777000));

var tokenDescriptor = new SecurityTokenDescriptor()
{
    Audience = &#34;https://appleid.apple.com&#34;,
    Expires = expiresAt,
    Issuer = &#34;{YOUR TEAM ID}&#34;,
    Subject = new ClaimsIdentity(new[] { new Claim(&#34;sub&#34;, &#34;{YOUR CLIENT ID}&#34;) }),
};

// Load the .p8 file from disk, removing the
// `-----BEGIN PRIVATE KEY-----` and `-----END PRIVATE KEY-----`
// prefix and suffix, and joining `\n` characters between lines.
string content = await File.ReadAllTextAsync(&#34;AuthKey_{YOUR KEY ID}.p8&#34;);

string[] keyLines = content.Split(&#39;\n&#39;);
content = string.Join(string.Empty, keyLines.Skip(1).Take(keyLines.Length - 2));

byte[] privateKey = Convert.FromBase64String(content);

// Create an ECDSA 256 algorithm to sign the token
using (var privateKey = CngKey.Import(keyBlob, CngKeyBlobFormat.Pkcs8PrivateBlob))
using (var algorithm = new ECDsaCng(privateKey))
{
    algorithm.HashAlgorithm = CngAlgorithm.Sha256;

    var key = new ECDsaSecurityKey(algorithm) { KeyId = &#34;{YOUR KEY ID}&#34; };

    // Set the signing key for the token
    tokenDescriptor.SigningCredentials = new SigningCredentials(
        key,
        SecurityAlgorithms.EcdsaSha256Signature);

    // Create the token, which acts as the Client Secret
    var tokenHandler = new JwtSecurityTokenHandler();
    string clientSecret = tokenHandler.CreateEncodedJwt(tokenDescriptor);
}
</code></pre><p>Within the provider prototype, the generated Client Secret is cached until it expires, at which point it is re-generated. Integrators can customise this behaviour by providing their own implementation of <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/b9a72d4928eff6bfe550e5f3abb3da3c81199090/src/AspNet.Security.OAuth.Apple/AppleClientSecretGenerator.cs title="AppleClientSecretGenerator class on GitHub.com"><code>AppleClientSecretGenerator</code></a>.</p><h3 id=cross-platform-support>Cross-platform Support</h3><p>Once the Client Secret was being generated successfully from the <code>.p8</code> file as-needed, I figured the bulk of the implementation was pretty much done.</p><p>As it turned out, I&rsquo;d made some assumptions in the implementation from working on my Windows 10 laptop that meant that the provider only worked on Windows and not on Linux or <a href=https://travis-ci.com/martincostello/AspNet.Security.OAuth.Providers/jobs/206552010#L968>macOS</a>, which is a bit embarrassing for integrating with an Apple product, let alone on cross-platform .NET Core.</p><p>First this required changing the code so it could use more generic ECDA APIs to load the <code>.p8</code> private key from Linux and macOS. A bit of Google-fu later lead to me finding <a href=https://github.com/dotnet/corefx/issues/18733 title="why CngKey.Import is not supported on ubuntu?">this issue</a> in Core CLR. It turns out that PKCS #8 keys aren&rsquo;t supported in .NET Core 2.x on non-Windows platforms. This is <a href=https://github.com/dotnet/corefx/pull/30271 title="Add support for importing/exporting asymmetric key formats">fixed in .NET Core 3.0</a>, but that doesn&rsquo;t do us any good right now.</p><p>To fix this I followed <a href=https://github.com/dotnet/corefx/issues/18733#issuecomment-296723615>these instructions</a> to generate a <code>.pfx</code> file (PKCS #12) from the <code>.p8</code> file and then use the <code>X509Certificate2</code> class to load the key instead (<a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/318/commits/0683f718719bf7f225e954c9eec57f7c909b7361 title="Fix Linux and macOS secret generation">commit</a>) on non-Windows platforms. It&rsquo;s a bit bleurgh to have to branch the code based on the operating system <em>and</em> require a different key format, but without pulling in <em>a lot</em> of extra code I didn&rsquo;t think it was worth it.</p><p>Unfortunately, that didn&rsquo;t fix everything either. It fixed Linux but <a href=https://travis-ci.com/martincostello/AspNet.Security.OAuth.Providers/jobs/206584185#L968>macOS was still broken</a>. This time it was because of <a href=https://github.com/dotnet/corefx/issues/24225 title="X509Certificate2/CommonCrypto: Unable to open PKCS#12 files with no password and valid MAC">this issue</a> where macOS cannot open private keys with no password set.</p><p>This required me to add a <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/318/commits/a088f736c2ebc2314f93195cd61f14aadb94657>further option</a> to support specifying a password for the certificate, which on reflection I should have done anyway. I was just being lazy in my tests.</p><p>With that change done, finally everything was working as expected on both Windows, Linux and macOS!</p><p>I merged the provider prototype changes to the ASP.NET Core 3.0 preview 5 branch of <em>AspNet.Security.OAuth.Providers</em> and took a look at the new APIs added to see if it could remove the need to fork the code. In fact <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/commit/ee4a2f7ca3d0f1550d3f3990a63e9fb01158caf9 title="Support PKCS 8 keys on macOS and Linux">it does neatly</a>, meaning that the ASP.NET Core 3.0 version of the provider would be able to work exactly the same using just the <code>.p8</code> private key without the need for a password option on all three operating systems.</p><pre tabindex=0><code>// Load the .p8 file from disk, removing the
// `-----BEGIN PRIVATE KEY-----` and `-----END PRIVATE KEY-----`
// prefix and suffix, and joining `\n` characters between lines.
byte[] privateKey = ...;

// Create an ECDSA 256 algorithm to sign the token
using var algorithm = ECDsa.Create();
algorithm.ImportPkcs8PrivateKey(privateKey, out int _);

var key = new ECDsaSecurityKey(algorithm) { KeyId = &#34;{YOUR KEY ID}&#34; };

// Generate the token...
</code></pre><h3 id=putting-it-all-together>Putting it all together</h3><p>With the provider prototype fully functional, the only code required to add <em>Sign In with Apple</em> support to an existing ASP.NET Core 2.x (or 3.0 preview) application can be as little as:</p><pre tabindex=0><code>.AddApple(options =&gt;
{
    options.ClientId = Configuration[&#34;AppleClientId&#34;];
    options.KeyId = Configuration[&#34;AppleKeyId&#34;];
    options.TeamId = Configuration[&#34;AppleTeamId&#34;];

    options.UsePrivateKey(
        (keyId) =&gt;
            HostingEnvironment.ContentRootFileProvider.GetFileInfo($&#34;AuthKey_{keyId}.p8&#34;));
})
</code></pre><p>One last <em>&ldquo;gotcha&rdquo;</em>: if you&rsquo;re using Azure App Service, you must set the <code>WEBSITE_LOAD_USER_PROFILE</code> application setting for your deployment slot to a value of <code>1</code>; otherwise, the application will not be able to load the private key from your <code>.p8</code> file.</p><h2 id=conclusion>Conclusion</h2><p>So after a weekend&rsquo;s work, I think I&rsquo;ve gotten a fairly nice prototype working that makes <em>Sign In with Apple</em> easy to integrate into an existing ASP.NET Core 2.x application based on the currently available functionality and documentation.</p><p>There&rsquo;s still a few rough edges, such as the disparate private key support between Windows (PKCS #8) and Linux/macOS (PKCS #12), and the lack of an ability to <em>actually</em> get the signed-in user&rsquo;s name and email address. Otherwise things work and should be easy to tweak and build upon for later beta releases of the service between now and when it becomes generally available to Apple users later in 2019.</p><p>If you&rsquo;ve got any feedback on the provider prototype, feel free to leave a comment on the <a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/318 title="Sign in With Apple provider Pull Request">Pull Request</a> over on GitHub!</p><h2 id=links>Links</h2><ul><li><a href=https://developer.apple.com/sign-in-with-apple/ title="Sign In with Apple - developer.apple.com">Sign In with Apple</a></li><li><a href=https://developer.apple.com/documentation/signinwithapplerestapi title="Sign In with Apple REST API - developer.apple.com">Sign In with Apple REST API</a></li><li><a href=https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple title="What the Heck is Sign In with Apple? - developer.okta.com"><em>&ldquo;What the Heck is Sign In with Apple?&rdquo;</em></a></li><li><a href=https://auth0.com/blog/what-is-sign-in-with-apple-a-new-identity-provider/ title="Sign In with Apple: Learn About the New Identity Provider - auth0.com"><em>&ldquo;What is Sign In with Apple?</em></a></li><li><a href=https://signinwithapple.azurewebsites.net/ title="Sign In with Apple demo app - signinwithapple.azurewebsites.net">Sign In with Apple demo app</a></li><li><a href=https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/318 title="Sign in With Apple provider - github.com">Sign In with Apple OAuth 2.0 provider for ASP.NET Core 2.x</a></li></ul><hr><p><div class=row><div class=col-lg-6><a href="https://bsky.app/intent/compose?text=Prototyping+Sign+In+with+Apple+for+ASP.NET+Core+by+%40martincostello.com+-+https%3A%2F%2Fblog.martincostello.com%2Fprototyping-sign-in-with-apple-for-asp.net-core%2F" target=_blank rel=noopener class="btn btn-info btn-sm" title="Share on Bluesky">Share on Bluesky
<span class="fa-brands fa-bluesky" aria-hidden=true></span></a></div></div></p><hr><footer><p><div class=row><div class="d-none d-md-block col">&copy; Martin Costello 2014-2025 |
Built from <a href=https://github.com/martincostello/blog/commit/4116b929c2636f9c037d8c2a6c02e0a2140cd9fc rel=noopener title="View commit 4116b929c2636f9c037d8c2a6c02e0a2140cd9fc on GitHub">4116b92</a> on <a href=https://github.com/martincostello/blog/tree/copilot/fix-244 rel=noopener title="View branch copilot/fix-244 on GitHub">copilot/fix-244</a></div><div class=d-md-none><div class=col>&copy; Martin Costello 2014-2025</div></div></div></p></footer></main><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bootswatch/5.3.7/flatly/bootstrap.min.css integrity="sha512-O+EA0Agf5+pB8u7CtnIAYq/BKyFPMT8c0DFjmqLyfIJJ9Fm8GBohV/0H0TFaZ96+jieN8zUVY4IkSBso9z6hpg==" crossorigin=anonymous referrerpolicy=no-referrer async><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin=anonymous referrerpolicy=no-referrer async><link rel=stylesheet href=/styles/site.css><script src=https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.7/js/bootstrap.bundle.min.js integrity="sha512-Tc0i+vRogmX4NN7tuLbQfBxa8JkfUSAxSFVzmU31nVdHyiHElPPy2cWfFacmCJKw0VqovrzKhdd2TSTMdAxp2g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src="https://www.googletagmanager.com/gtag/js?id=G-XJFV74HRL6" async></script><script>window.hugoSiteParams={render_analytics:!0,analytics_id:"G-XJFV74HRL6"}</script><script src=/scripts/site.js defer></script></body></html>